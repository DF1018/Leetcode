<img width="721" height="515" alt="image" src="https://github.com/user-attachments/assets/18da2554-9603-48cd-b639-d4268397f792" />

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        tortoise = nums[0]
        hare = nums[0] 
        while True:
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            if tortoise == hare:
                break
        
        ptr1 = nums[0]
        ptr2 = tortoise

        while not ptr1 == ptr2:
            ptr1 = nums[ptr1]
            ptr2 = nums[ptr2]
        
        return ptr1
```

# Floyd Cycle Detection：兩個核心重點
---

## Lesson One：為什麼一定會相遇

### 與題目 [141. Linked List Cycle](https://github.com/DF1018/Leetcode/blob/main/Linked%20List/141.%20Linked%20List%20Cycle.md) 相同概念

快指針（F）每次比慢指針（S）多走 1 個節點，因此兩者之間的距離會以 **每次 1 個節點的速度縮短**。

```python
while True:
    tortoise = nums[tortoise]          # slow
    hare = nums[nums[hare]]            # fast
    if tortoise == hare:
        break
```

當距離縮到 0 時（n - 1 → 0），兩者必定相遇。

---

## Lesson Two：為什麼相遇點到起點的距離 = 環入口距離

```python
ptr1 = nums[0]      # 從起點出發
ptr2 = tortoise     # 從相遇點出發

while ptr1 != ptr2:
    ptr1 = nums[ptr1]
    ptr2 = nums[ptr2]
```

### 變數定義

* **p**：從起點到環入口的距離
* **C**：環的總長度
* **x**：慢指針在環內已經走過的距離

![VS--YouTube-FindtheDuplicateNumber-FloydsCycleDetection-Leetcode287-Python-12’54”](https://github.com/user-attachments/assets/518b1ca6-44a7-448e-bd18-bcc64372a777)
---

### 相遇的距離推導

快指針速度是慢指針的 2 倍：

### 2 ⋅ slow = fast

對應到距離（第一次相遇時）：

### slow = p + x

由於快指針在環內多繞了整整一圈：

### 2(p + x) = p + x + C

整理得：


### p = C - x


這表示：

**相遇點距離環入口的距離（C - x），剛好等於起點距離環入口的距離（p）。**

因此讓一個指針從起點走、一個從相遇點走，必定在入口碰頭。








