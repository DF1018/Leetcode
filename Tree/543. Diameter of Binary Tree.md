<img src="photo/543. Diameter of Binary Tree.jpg" width="700">

```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.res = 0

        def dfs(curr):
            if not curr:
                return 0
            
            left = dfs(curr.left) # 拿left該節點的高度
            right = dfs(curr.right) # 拿right該節點的高度

            self.res = max(self.res, left + right)
            return 1 + max(left, right) # return出那個節點的最大高度 
            
        dfs(root)
        return self.res
```

## 2025/11/27 第一次嘗試
```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        max_ans = 0

        left_tree = self.maxDepth(root.left)
        right_tree = self.maxDepth(root.right)
        return left_tree + right_tree
    
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

我本來的概念是
* 算出
  `root.left` 的最大深度 → `left_tree`
  `root.right` 的最大深度 → `right_tree`
* 回傳 `left_tree + right_tree`

問題在這裡：
> **二元樹的直徑不一定要經過整棵樹的 root**

## 2025/11/27 第二次嘗試
```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        self.max_ans = 0

        def dfs(node):
            if node is None:
                return 0
            L = dfs(node.left)
            R = dfs(node.right)
            self.max_ans = max((L + R), self.max_ans)
            return max(L, R) + 1

        dfs(root)
        return self.max_ans
```
