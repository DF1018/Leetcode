<img width="916" height="671" alt="image" src="https://github.com/user-attachments/assets/b96ecb02-61fc-4ef1-9857-cf6c0b271d8c" />

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        
        for i , a in enumerate(nums):
            if i > 0 and a==nums[i-1]:
                continue
            
            l , r = i+1 , len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r-=1
                elif threeSum < 0:
                    l+=1
                else:
                    res.append([a,nums[l],nums[r]])
                    l+=1
                    while nums[l] == nums[l-1] and l<r:
                        l+=1
        return res
```
<img width="953" height="265" alt="image" src="https://github.com/user-attachments/assets/aeb596c5-d9a7-430c-beb3-1fd9712d0e95" />

## 先將陣列排序，方便之後用雙指標（l, r）移動，並且能跳過重複的組合。
```
nums.sort()
res = []
```

## 外層迴圈：固定第一個數
```
for i, a in enumerate(nums):
    if i > 0 and a == nums[i - 1]:
        continue
```

## 固定第一個數 X ，再找 X 右邊的邊界 L 至 R
```
l, r = i + 1, len(nums) - 1
while l < r:
    threeSum = a + nums[l] + nums[r]
```

## 「找到一組解後」的重複處理與指標移動邏輯
<img width="324" height="64" alt="image" src="https://github.com/user-attachments/assets/c2b21542-2365-4e10-a3e2-8bf40bb84982" />

```
else:
    List.append([nums[i], nums[l], nums[r]])
    while l < r and nums[l] == nums[l+1]: # 左邊的數若重複（例如有多個 -2），
        l += 1                             # 就不需要再檢查相同的起點，
                                            # 直接跳過相同值。
        
    while l < r and nums[r] == nums[r-1]: # 右邊也同理。
        r -= 1                            # 連續的重複數會造成重複組合，所以要往左移動跳過重複值。
    l += 1 # 跳過重複後，再同時向內移動一格，
    r -= 1 # 繼續搜尋新的可能組合。
```



